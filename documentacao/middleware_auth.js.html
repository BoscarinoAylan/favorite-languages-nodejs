<h2>src/middleware/auth.js</h2>

<pre><code class="lang-js">const { checarToken } = require('../repository/blackList');
const { verificarToken } = require('../service/auth');

const autenticarRequisicao = (req, res, next) => {
    if (
        !req.headers.authorization ||
        req.headers.authorization.split(' ').length < 2
    ) {
        return res.status(401).json({ error: 'acesso não autorizado' });
    }
    const token = req.headers.authorization.split(' ')[1];

    checarToken(token).then(estaListado => {
        if (estaListado) {
            return res.status(401).json({ error: 'acesso não autorizado' });
        }
    });

    verificarToken(token, (err, payload) => {
        if (err) {
            return res.status(401).json({ error: 'acesso não autorizado' });
        }
        res.locals.payload = payload;
        return next();
    });
};

module.exports = { autenticarRequisicao };
</code></pre>

<h3>Visão Geral</h3>

<p>
    Esse módulo tem o papel de fornecer o middleware para autenticar as
    requisições enviadas à API para garantir que somentente usuários
    autenticados tenham acesso a certos endpoints da API.
</p>

<h3>Comentários</h3>

<ul>
    <li>
        <span class="lf-strong">Linha 1</span>: Importamos a função checarToken
        do repositório de blacklists que irá verificar se a token passada já foi
        marcada na lista negra como desautenticada.
        <pre><code class="lang-js">const { checarToken } = require('../repository/blackList');</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 2</span>: Importamos a função
        verificarToken do serviço de autenticação para verificar se o token é um
        token válido provido por esta aplicação.
        <pre><code class="lang-js">const { verificarToken } = require('../service/auth');</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 4</span>: Criamos a função de middleware
        autenticarRequisicao, por ser um middleware ela deverá ter como
        parâmetros um objeto pada requisição (req), um objeto para resposta
        (res) e a função next() que ao ser executada passa o controle da
        requisição para o próximo middleware do ciclos
        <pre><code class="lang-js">const autenticarRequisicao = (req, res, next) => {</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 5 a 10</span>: criamos uma estrutura
        condicional if que irá verificar se há o cabeçalho authorization dentre
        os headers da requisição e se esse cabeçalho possui ao menos dois itens.
        Caso uma dessas condições não seja verdadeira o middleware retornará uma
        resposta com status 401 informando que o acesso não é autorizado.
        <pre><code class="lang-js">if (
    !req.headers.authorization ||
    req.headers.authorization.split(' ').length < 2
) {
    return res.status(401).json({ error: 'acesso não autorizado' });
}</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 11</span>: Um cabeçalho authorization
        adequado para uma requisição feita a nossa api deve ser uma string com
        duas palavras: "Bearer" e o token em si. Iremos então separar essa
        string em um array e iremos armazenar o segundo item desse array em uma
        constante chamada token.
        <pre><code class="lang-js">const token = req.headers.authorization.split(' ')[1];</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 13 a 17</span>: Executamos a função
        checarToken passando o token em seu parâmetro, como essa função retorna
        uma Promise iremos então executar seu then(), passamos-lhe então uma
        função callback que terá em seu parâmetro um booleano indicando se o
        token está autenticado ou não, se estiver o middleware retornará uma
        resposta com status 401 informando que o acesso não é autorizado.
        <pre><code class="lang-js">checarToken(token).then(estaListado => {
    if (estaListado) {
        return res.status(401).json({ error: 'acesso não autorizado' });
    }
});</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 19</span>: Executamos a função
        verificarToken passando em seus parâmetros o token que iremos verificar
        e uma função callback que será executada após a verificação ser feita,
        quando a callback for executada ela receberá dois parâmetros: o primeiro
        será um erro que estará vazio se o token for válido e o segundo é o
        payload com os dados do token, caso autenticado.
        <pre><code class="lang-js">verificarToken(token, (err, payload) => {</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 20 a 22</span>: A primeira coisa que
        faremos na função callback é definir se houve um erro na verificação do
        token, se houver retornaremos uma resposta com status 401 informando que
        o acesso não é autorizado.
        <pre><code class="lang-js">if (err) {
    return res.status(401).json({ error: 'acesso não autorizado' });
}</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 23 a 26</span>: Por fim, se o token for
        verificado como válido, iremos passar armazenar seu payload no atributo
        res.locals.payload, isso permite que outros middlewares tenham acesso a
        essas informações. Retornamos a execução da função next() para que o
        próximo middleware assuma o controle do ciclo requisição-resposta.
        fechamos a callback e fechamos autenticarRequisicao.
        <pre><code class="lang-js">        res.locals.payload = payload;
        return next();
    });
};</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 28</span>: Exportamos a função
        autenticarRequisicao para que possa ser usada pelo resto da aplicação.
        <pre><code class="lang-js">module.exports = { autenticarRequisicao };</code></pre>
    </li>
</ul>
