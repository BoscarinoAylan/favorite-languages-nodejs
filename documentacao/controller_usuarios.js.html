<h2>src/controller/usuarios.js</h2>

<pre><code class="lang-js">const { cadastrarUsuario, logarUsuario } = require('../repository/usuarios');
const { listarToken } = require('../repository/blackList');

const cadastro = (req, res, next) => {
    const dadosUsuario = req.body;

    return cadastrarUsuario(dadosUsuario)
        .then(usuario => {
            if (!usuario.cadastrado) {
                return res.status(409).json({ msg: 'E-mail já cadastrado.' });
            }
            return res.json(usuario.token);
        })
        .catch(error => next(error));
};

const login = (req, res, next) => {
    const { email, senha } = req.body;

    return logarUsuario(email, senha)
        .then(usuario => {
            if (!usuario.autenticado) {
                return res
                    .status(401)
                    .json({ err: 'E-mail ou senha inválidos.' });
            }
            return res.json(usuario.token);
        })
        .catch(error => next(error));
};

const logout = (req, res, next) => {
    const token = req.headers.authorization.split(' ')[1];
    return res.json(listarToken(token));
};

module.exports = { cadastro, login, logout };
</code></pre>

<h3>Visão Geral</h3>

<p>
    Este módulo será responsável por tratar as requisições enviadas pelo cliente
    e enviar-lhes respostas adequadas, utilizando das abstrações de comunidações
    com as entidades, os repositórios, para buscar os dados solicitados pelas
    requisições dos clientes.
</p>

<h3>Comentários</h3>

<ul>
    <li>
        <span class="lf-strong">Linhas 1 e 2</span>: Importamos as funções dos
        repositórios que serão usadas nesse módulo: cadastrarUsuario e
        logarUsuario do repositório de usuários e listarToken do repositório de
        black lists.
        <pre><code class="lang-js">const { cadastrarUsuario, logarUsuario } = require('../repository/usuarios');
const { listarToken } = require('../repository/blackList');</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 4 e 5</span>: Criamos a função cadastro
        que será executada quando o usuário não autenticado acessar o endpoint
        de cadastro da nossa API, em seguida armazenamos os dados do usuário em
        uma constante.
        <pre><code class="lang-js">const cadastro = (req, res, next) => {
    const dadosUsuario = req.body;</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 7</span>: Retornamos a execução da função
        cadastrarUsuario, como essa função retorna uma Promise executamos seu
        then() passando-lhe uma função callback cujo parâmetro será um objeto
        referente ao usuário.
        <pre><code class="lang-js">return cadastrarUsuario(dadosUsuario).then(usuario => {</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linahs 8 a 10</span>: Criamos uma estrutura
        condicional para verificar se o usuário foi cadastrado, caso não seja
        retornamos uma resposta com status 409 (conflito) e uma mensagem
        informando que o e-mail não está disponível.
        <pre><code class="lang-js">if (!usuario.cadastrado) {
    return res.status(409).json({ msg: 'E-mail já cadastrado.' });
}</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 12</span>: Caso oo usuário tenha sido
        devidamente cadastrado retornamos uma resposta com o token JWT
        devidamente validado ao cliente.
        <pre><code class="lang-js">return res.json(usuario.token);</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 14</span>: Caso ocorra algum erro durante
        a execução da Promise catch() será executado, passamos em seu parâmetro
        uma função callback que receberá o erro em seu parâmetro, iremos então
        passar esse erro na execução de next() para que o erro seja direcionado
        ao middleware de tratamento de erros.
        <pre><code class="lang-js">.catch(error => next(error));</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 17 e 18</span>: Criamos a função login
        que será responsável por autenticar os dados recebidos no corpo da
        requisição do usuário e, caso estejam corretos, enviar o token JWT
        assinado. Desempacotamos os valores de email e senha do corpo da
        requisição e os armazenamos em constantes
        <pre><code class="lang-js">const login = (req, res, next) => {
    const { email, senha } = req.body;</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 20 e 21</span>: Retornamos a execução de
        logarUsuario passando em seus parâmetros os valores de email e senha,
        como esta função retorna uma Promise executaremos seu then()
        passando-lhe uma função callback que terá em seu parâmetro um objeto
        referente ao usuário
        <pre><code class="lang-js">return logarUsuario(email, senha)
    .then(usuario => {</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 22 a 26</span>: Criamos uma estrutura
        condicional para verificar se o usuário foi devidamente autenticado,
        caso não tenha sido iremos retornar uma resposta com status 401 (não
        autorizado) com uma mensagem indicando que os dados informados não são
        válidos

        <pre><code class="lang-js">if (!usuario.autenticado) {
    return res
        .status(401)
        .json({ err: 'E-mail ou senha inválidos.' });
}</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 27</span>: Caso o usuário tenha sido
        devidamente autenticado retornamos uma resposta com o token JWT
        assinado.
        <pre><code class="lang-js">return res.json(usuario.token);</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 29</span>: Caso ocorra algum erro durante
        a execução da Promise catch() será executado, passamos em seu parâmetro
        uma função callback que receberá o erro em seu parâmetro, iremos então
        passar esse erro na execução de next() para que o erro seja direcionado
        ao middleware de tratamento de erros.
        <pre><code class="lang-js">.catch(error => next(error));</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 32</span>: Criamos a função de logout que
        irá tratar de invalidar o token que o usuário estiver usando no
        cabeçalho de sua requisição.
        <pre><code class="lang-js">const logout = (req, res, next) => {</code></pre>
    </li>
    <li>
        <span class="lf-strong">linha 33</span>: Armazenamos o valor do token
        informado no cabeçalho em uma constante, como o cabeçalho é composto por
        uma string de duas palavras, sendo a primeira "Bearer", utilizamos a
        função split(' ') para separá-la em um array e buscamos o segundo item
        dele.
        <pre><code class="lang-js">const token = req.headers.authorization.split(' ')[1];</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 34</span>: Por fim retornamos a resposta
        com a execução de listarToken que irá invalidar o token que for passado
        em seu parâmetro.
        <pre><code class="lang-js">return res.json(listarToken(token));</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 37</span>: Exportamos as funções do
        middleware para que possam ser usadas em outras partes da aplicação.
        <pre><code class="lang-js">module.exports = { cadastro, login, logout };</code></pre>
    </li>
    <li>
        <span class="lf-strong"></span>
        <pre><code class="lang-js"></code></pre>
    </li>
    <li>
        <span class="lf-strong"></span>
        <pre><code class="lang-js"></code></pre>
    </li>
</ul>
