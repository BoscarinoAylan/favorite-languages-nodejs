<h2>src/database/database.js</h2>

<pre><code class="lang-js">const mongoose = require('mongoose');
const environment = process.env.ENV || 'development';
const {
    database: { name, port, host }
} = require('../config/config')[environment];

const connect = callback => {
    mongoose.promise = global.Promise;
    mongoose.connect(
        `mongodb://${host}/${name}`,
        { useNewUrlParser: true },
        callback
    );
};

module.exports = { connect };
</code></pre>

<h3>Visão Geral</h3>
<p>
    Esse módulo é responsável por conectar a aplicação ao banco de dados MongoDB
    que esta utilizará, utilizaremos a biblioteca externa mongoose para realizar
    essa conexão.
</p>

<h3>Comentários</h3>

<ul>
    <li>
        <span class="lf-strong">Linha 1</span>: Importamos a bilbioteca mongoose
        a partir da qual criaremos a conexão entre nosso sistema e o bando
        MongoDB
        <pre><code class="lang-js">const mongoose = require('mongoose');</code></pre>
    </li>

    <li>
        <span class="lf-strong">Linha 2</span>: Armazenamos na constante
        environment o valor da variável de ambiente ENV para indicar em qual
        ambiente a aplicação está. Caso não exista o ambiente será o de
        desenvolvimento 'development'.
        <pre><code class="lang-js">const environment = process.env.ENV || 'development';</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 3 a 5</span>: Iremos desempacotar as
        variáveis name, port e host do objeto database que se encontra no
        arquivo de configuração da nossa aplicação, passamos o ambiente no
        índice do objeto sendo importado para buscar os dados referentes ao
        ambiente em que a aplicação está sedo executada.

        <pre><code class="lang-js">const {
    database: { name, port, host }
} = require('../config/config')[environment];</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 7</span>: : Criamos então uma função de
        alta ordem de nome connect, ela é uma função de altar ordem porque irá
        receber uma nova função, uma callback, em seu argumento.
        <pre><code class="lang-js"></code>const connect = callback => {</pre>
    </li>
    <li>
        <span class="lf-strong">Linha 8</span>: Armazenamos o objeto
        global.Promise dentro do atributo monboose.promise, isto é feito porque
        o mongoose não utiliza Promises tradicionais do Javascript por padrão,
        para que haja esse comportamento precisamos definir explicitamente desta
        forma.
        <pre><code class="lang-js">mongoose.promise = global.Promise;</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linhas 9 a 13</span>: Executamos o método
        mongoose.connect() para conectar nossa aplicação ao banco de dados,
        passamos três parâmetros a este método: o primeiro é uma string com os
        dados do banco ao qual queremos nos conectar, utilizamos template de
        strings `` para que possamos inserir as variáveis host e name dentro da
        string sem precisar utilizar concatenação; O segundo parâmetro é um
        objeto com o atribto useNewUrlParser como true para infromar ao mongoose
        que queremos utilizar o novo parser de url; O último atributo é a função
        callback que é passada noa tributo de connect, essa callback será
        executada uma vez que o mongoose finalizar sua conexão e passará um erro
        no parÂmetro desta casso um problema ocorra.

        <pre><code class="lang-js">mongoose.connect(
    `mongodb://${host}/${name}`,
    { useNewUrlParser: true },
    callback
);</code></pre>
    </li>
    <li>
        <span class="lf-strong">Linha 16</span>: Por fim exportamos a função
        connect para que possa ser usada em outras partes da aplicação
        <pre><code class="lang-js">module.exports = { connect };</code></pre>
    </li>
</ul>
